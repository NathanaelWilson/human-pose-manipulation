# -*- coding: utf-8 -*-
"""Human Pose Manipulation using LoRA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b1nXrFfXnuIDzx3F7nxrcH4CUK7ycDGC

# Adaptive Text-Driven Human Pose Manipulation using LoRA-Augmented InstructPix2Pix Pipelines


A production-ready, optimized text-guided image editing system built on Stable Diffusion with advanced attention control and masking for precise, localized edits.


**Architecture:**
- Base: Stable Diffusion v1.5
- Precision: FP16 mixed precision
- Resolution: 512x512 (expandable)
- Inference Steps: 4-8 steps with DPM-Solver++

![archite.jpg](data:image/jpeg;base64,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)

## 1. Setup & Installation

First, install all required dependencies. Run this cell once to set up your environment.
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install torch torchvision
# %pip install diffusers transformers accelerate safetensors pillow
# %pip install xformers  # For memory-efficient attention
# %pip install peft  # For LoRA support
# %pip install peft bitsandbytes  # Tambahkan ini di cell instalasi

# Commented out IPython magic to ensure Python compatibility.
# %pip install controlnet-aux  # For ControlNet preprocessing (Canny, Depth, etc.)
# %pip install opencv-python  # For image processing
# %pip install scipy  # For advanced image operations

"""### Import Dependencies

"""

import torch
import torch.nn as nn
import torch.nn.functional as F
from diffusers import (
    StableDiffusionInstructPix2PixPipeline,
    StableDiffusionControlNetPipeline,
    ControlNetModel,
    AutoencoderKL,
    UNet2DConditionModel,
    DDPMScheduler,
    DPMSolverMultistepScheduler,
    EulerAncestralDiscreteScheduler,
)
from transformers import CLIPTextModel, CLIPTokenizer
from PIL import Image, ImageEnhance, ImageFilter
import numpy as np
from typing import Optional, Union, List, Tuple
import warnings
from dataclasses import dataclass
import time
import cv2

# ControlNet preprocessors
try:
    from controlnet_aux import CannyDetector, MidasDetector
    CONTROLNET_AVAILABLE = True
except ImportError:
    print(" controlnet-aux not installed. ControlNet features will be limited.")
    CONTROLNET_AVAILABLE = False

# Set device
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(f"Using device: {device}")

if torch.cuda.is_available():
    print(f"GPU: {torch.cuda.get_device_name(0)}")
    print(f"VRAM: {torch.cuda.get_device_properties(0).total_memory / 1024**3:.2f} GB")

warnings.filterwarnings("ignore")
print(" All imports loaded successfully")

"""## 2. Configuration

Configure model settings and optimization parameters for your hardware.
"""

@dataclass
class ModelConfig:
    use_instruct_pix2pix: bool = True  # Use InstructPix2Pix
    instruct_pix2pix_model: str = "timbrooks/instruct-pix2pix"
    base_model_id: str = "runwayml/stable-diffusion-v1-5"
    precision: str = "fp16"  # fp16, bf16, or fp32

    use_controlnet: bool = True  # Enable structure preservation
    controlnet_type: str = "canny"  # "canny" for edges, "depth" for 3D structure
    controlnet_conditioning_scale: float = 0.5  # How strongly to preserve structure (0.3-0.8)

    image_size: int = 512  # Target image size (512 or 768)

    num_inference_steps: int = 20  # More steps = better quality (15-30 recommended)
    guidance_scale: float = 7.5  # Text prompt adherence
    image_guidance_scale: float = 1.5  # Image conditioning strength (InstructPix2Pix)

    use_multipass: bool = False  # Progressive refinement (slower but better)
    num_passes: int = 2  # Number of refinement passes (1-3)

    enable_attention_slicing: bool = True  # Reduce memory usage
    enable_xformers: bool = True  # Use xformers for efficient attention
    enable_vae_tiling: bool = False  # Enable for larger images
    enable_cpu_offload: bool = False  # Offload to CPU if low VRAM

    mask_threshold: float = 0.3  # Threshold for automatic masking
    mask_blur: int = 4  # Blur radius for mask smoothing
    enhance_details: bool = True  # Post-process enhancement

    auto_enhance_prompts: bool = True  # Automatically improve prompts
    negative_prompt: str = "blurry, low quality, distorted, deformed, artifacts"

    lora_path: Optional[str] = None  # Path ke folder hasil fine-tune

# Create default config
config = ModelConfig()
print("Configuration loaded successfully!")
# print(f"Model: {config.model_id}")
print(f"Precision: {config.precision}")
print(f"Image size: {config.image_size}x{config.image_size}")
print(f"Inference steps: {config.num_inference_steps}")

"""## 3. Professional Image Editor - UPGRADED

Complete professional-grade editing system with InstructPix2Pix + ControlNet + Advanced Features

"""

class ProfessionalImageEditor:
    """
     Professional Text-Guided Image Editor - UPGRADED VERSION

    Features:
    - InstructPix2Pix for superior editing quality
    - ControlNet for perfect structure preservation
    - Multi-pass refinement for progressive improvement
    - Advanced prompt engineering
    - Smart detail enhancement
    - Optimized for 12-16GB VRAM
    """

    def __init__(self, config: ModelConfig = None):
        self.config = config or ModelConfig()
        self.device = device
        self.dtype = self._get_dtype()

        print("Loading Professional Image Editor...")
        print(f"Mode: {'InstructPix2Pix' if config.use_instruct_pix2pix else 'Standard'}")
        print(f"ControlNet: {'Enabled' if config.use_controlnet else 'Disabled'}")

        self._load_models()
        self._setup_optimizations()

        # Initialize ControlNet preprocessors
        if config.use_controlnet and CONTROLNET_AVAILABLE:
            self._init_controlnet_preprocessors()

        print("Professional image editor ready!")
        print(f"VRAM: ~{self._estimate_vram()}GB")

    def _get_dtype(self):
        """Get torch dtype from config"""
        if self.config.precision == "fp16":
            return torch.float16
        elif self.config.precision == "bf16":
            return torch.bfloat16
        else:
            return torch.float32

    def _estimate_vram(self):
        """Estimate VRAM usage"""
        base = 4 if self.config.use_instruct_pix2pix else 3
        controlnet = 1.5 if self.config.use_controlnet else 0
        return base + controlnet + 4  # +4 for activations

    def _load_models(self):
        """Load main editing pipeline"""
        if self.config.use_instruct_pix2pix:
            print("   Loading InstructPix2Pix (trained for editing)...")
            self.pipe = StableDiffusionInstructPix2PixPipeline.from_pretrained(
                self.config.instruct_pix2pix_model,
                torch_dtype=self.dtype,
                safety_checker=None
            ).to(self.device)

            # BAGIAN MENARUH LORA
            if self.config.lora_path:
                print(f"Loading Fine-Tuned LoRA from: {self.config.lora_path}")
                try:
                    # Kita gunakan library PEFT langsung agar kuncinya cocok
                    from peft import PeftModel

                    # Load adapter ke dalam UNet
                    self.pipe.unet = PeftModel.from_pretrained(
                        self.pipe.unet,
                        self.config.lora_path
                    )
                    print("LoRA weights loaded successfully via PeftModel!")
                except Exception as e:
                    print(f"Failed to load LoRA: {e}")

        else:
            print("   Loading standard SD pipeline...")
            from diffusers import StableDiffusionImg2ImgPipeline
            self.pipe = StableDiffusionImg2ImgPipeline.from_pretrained(
                self.config.base_model_id,
                torch_dtype=self.dtype,
                safety_checker=None
            ).to(self.device)

        # Load ControlNet if enabled
        if self.config.use_controlnet:
            print(f"   Loading ControlNet ({self.config.controlnet_type})...")
            controlnet_model = f"lllyasviel/control_v11p_sd15_{self.config.controlnet_type}"
            try:
                self.controlnet = ControlNetModel.from_pretrained(
                    controlnet_model,
                    torch_dtype=self.dtype
                ).to(self.device)

                # Create ControlNet pipeline
                self.controlnet_pipe = StableDiffusionControlNetPipeline(
                    vae=self.pipe.vae,
                    text_encoder=self.pipe.text_encoder,
                    tokenizer=self.pipe.tokenizer,
                    unet=self.pipe.unet,
                    controlnet=self.controlnet,
                    scheduler=self.pipe.scheduler,
                    safety_checker=None,
                    feature_extractor=None
                ).to(self.device)
                print("    ControlNet loaded successfully")
            except Exception as e:
                print(f"    ControlNet loading failed: {e}")
                self.config.use_controlnet = False

    def _setup_optimizations(self):
        """Apply memory and speed optimizations"""
        if self.config.enable_xformers:
            try:
                self.pipe.enable_xformers_memory_efficient_attention()
                if hasattr(self, 'controlnet_pipe'):
                    self.controlnet_pipe.enable_xformers_memory_efficient_attention()
                print("    xformers enabled")
            except Exception as e:
                print(f"    xformers not available")

        if self.config.enable_attention_slicing:
            self.pipe.enable_attention_slicing(1)
            if hasattr(self, 'controlnet_pipe'):
                self.controlnet_pipe.enable_attention_slicing(1)

        if self.config.enable_vae_tiling:
            self.pipe.enable_vae_tiling()
            if hasattr(self, 'controlnet_pipe'):
                self.controlnet_pipe.enable_vae_tiling()

        if self.config.enable_cpu_offload:
            self.pipe.enable_model_cpu_offload()
            if hasattr(self, 'controlnet_pipe'):
                self.controlnet_pipe.enable_model_cpu_offload()

    def _init_controlnet_preprocessors(self):
        if self.config.controlnet_type == "canny":
            self.preprocessor = CannyDetector()
        elif self.config.controlnet_type == "depth":
            self.preprocessor = MidasDetector.from_pretrained("lllyasviel/Annotators")
        print(f"    {self.config.controlnet_type} preprocessor ready")

    def _enhance_prompt(self, prompt: str) -> str:
        if not self.config.auto_enhance_prompts:
            return prompt

        # Don't enhance if already detailed
        if len(prompt.split()) > 15:
            return prompt

        quality_terms = "high quality, detailed, professional"
        return f"{prompt}, {quality_terms}"

    def _preprocess_controlnet_image(self, image: Image.Image) -> Image.Image:
        if not hasattr(self, 'preprocessor'):
            return image

        if self.config.controlnet_type == "canny":
            # Detect edges
            control_image = self.preprocessor(image, low_threshold=100, high_threshold=200)
        elif self.config.controlnet_type == "depth":
            # Estimate depth
            control_image = self.preprocessor(image)
        else:
            control_image = image

        return control_image

    def _enhance_details(self, image: Image.Image) -> Image.Image:
        """Post-process enhancement"""
        if not self.config.enhance_details:
            return image

        # Slight sharpening
        enhancer = ImageEnhance.Sharpness(image)
        image = enhancer.enhance(1.1)

        # Slight contrast boost
        enhancer = ImageEnhance.Contrast(image)
        image = enhancer.enhance(1.05)

        return image



    @torch.no_grad()
    def edit_image(self,
                   image: Union[str, Image.Image],
                   prompt: str,  # Simplified: just the edit instruction
                   num_inference_steps: Optional[int] = None,
                   guidance_scale: Optional[float] = None,
                   image_guidance_scale: Optional[float] = None,
                   use_controlnet: Optional[bool] = None,
                   controlnet_scale: Optional[float] = None,
                   enhance_output: Optional[bool] = None,
                   seed: Optional[int] = None) -> Tuple[Image.Image, Optional[Image.Image]]:

        start_time = time.time()

        # Set seed
        if seed is not None:
            torch.manual_seed(seed)
            if torch.cuda.is_available():
                torch.cuda.manual_seed(seed)

        # Use defaults from config
        num_inference_steps = num_inference_steps or self.config.num_inference_steps
        guidance_scale = guidance_scale or self.config.guidance_scale
        image_guidance_scale = image_guidance_scale or self.config.image_guidance_scale
        use_controlnet = use_controlnet if use_controlnet is not None else self.config.use_controlnet
        controlnet_scale = controlnet_scale or self.config.controlnet_conditioning_scale
        enhance_output = enhance_output if enhance_output is not None else self.config.enhance_details

        # Load image
        if isinstance(image, str):
            image = Image.open(image).convert("RGB")

        # Resize to target size
        original_size = image.size
        image = image.resize((self.config.image_size, self.config.image_size), Image.LANCZOS)

        # Enhance prompt
        enhanced_prompt = self._enhance_prompt(prompt)

        print(f"Editing: '{prompt}'")
        print(f"Steps: {num_inference_steps}, Guidance: {guidance_scale}")

        control_image = None

        # Use ControlNet if enabled
        if use_controlnet and hasattr(self, 'controlnet_pipe') and CONTROLNET_AVAILABLE:
            print(f"Using ControlNet ({self.config.controlnet_type}) for structure preservation...")
            control_image = self._preprocess_controlnet_image(image)

            result = self.controlnet_pipe(
                prompt=enhanced_prompt,
                negative_prompt=self.config.negative_prompt,
                image=control_image,
                num_inference_steps=num_inference_steps,
                guidance_scale=guidance_scale,
                controlnet_conditioning_scale=controlnet_scale,
            ).images[0]

        # Use InstructPix2Pix
        elif self.config.use_instruct_pix2pix:
            result = self.pipe(
                prompt=enhanced_prompt,
                image=image,
                num_inference_steps=num_inference_steps,
                guidance_scale=guidance_scale,
                image_guidance_scale=image_guidance_scale,
                negative_prompt=self.config.negative_prompt,
            ).images[0]

        # Standard img2img
        else:
            result = self.pipe(
                prompt=enhanced_prompt,
                image=image,
                num_inference_steps=num_inference_steps,
                guidance_scale=guidance_scale,
                negative_prompt=self.config.negative_prompt,
            ).images[0]

        # Multi-pass refinement
        if self.config.use_multipass and self.config.num_passes > 1:
            print(f"   Applying {self.config.num_passes-1} refinement passes...")
            for i in range(self.config.num_passes - 1):
                result = self.pipe(
                    prompt=enhanced_prompt,
                    image=result,
                    num_inference_steps=num_inference_steps // 2,
                    guidance_scale=guidance_scale * 0.9,
                    image_guidance_scale=image_guidance_scale * 0.8,
                ).images[0]

        # Post-process enhancement
        if enhance_output:
            result = self._enhance_details(result)

        # Resize back to original
        if result.size != original_size:
            result = result.resize(original_size, Image.LANCZOS)

        elapsed = time.time() - start_time
        print(f"Complete in {elapsed:.2f}s")

        return result, control_image


print("Professional Image Editor class loaded")

"""## 4. Initialize the Professional Editor

"""

print("="*70)
print(" PROFESSIONAL IMAGE EDITOR - UPGRADED VERSION")
print("="*70)
print()

editor = ProfessionalImageEditor(config)

print()
print("="*70)
print(" Ready to create professional-quality edits!")
print("="*70)

"""# FINE TUNE"""

import torch
from torch.utils.data import Dataset, DataLoader
from torchvision import transforms
from diffusers import StableDiffusionInstructPix2PixPipeline, DDPMScheduler
from peft import LoraConfig, get_peft_model
from PIL import Image
import json
import os
from tqdm.auto import tqdm

# ==========================================
# 1. KONFIGURASI PROYEK
# ==========================================
OUTPUT_DIR = "./dataset"
IMAGES_DIR = os.path.join(OUTPUT_DIR, "images")
METADATA_PATH = os.path.join(OUTPUT_DIR, "metadata.jsonl")

NUM_SAMPLES = 200

# Gunakan GPU jika ada, jika tidak pakai CPU (lambat)
device = "cuda" if torch.cuda.is_available() else "cpu"
print(f"Menggunakan device: {device}")

from diffusers import StableDiffusionXLPipeline
import torch

# ==========================================
# 2. INISIALISASI MODEL (SDXL BASE 1.0)
# ==========================================
model_id = "stabilityai/stable-diffusion-xl-base-1.0"

# PENTING: Untuk SDXL harus pakai StableDiffusionXLPipeline, bukan StableDiffusionPipeline biasa
pipe = StableDiffusionXLPipeline.from_pretrained(
    model_id,
    torch_dtype=torch.float16 if device == "cuda" else torch.float32,
    use_safetensors=True, # Menggunakan format safetensors agar load lebih cepat
    variant="fp16"        # Wajib pakai variant fp16 agar ukuran model tidak terlalu besar (kurang dari 10GB)
)

# Pindahkan ke GPU
pipe = pipe.to(device)

# ==========================================
# 3. GENERATOR PROMPT OTOMATIS
# ==========================================
# Kita butuh variasi agar model pintar. Kita acak Subject, Background, dan Style.

subjects = [
    "a man", "a woman",
]

backgrounds = [
    "on a white background"
]

styles = [
    "photo", "realistic", "4k"
]

instructions = [
    "make the person sit down", "change the pose to sitting",
    "make the character sit", "sit on a bench", "sit on a chair",
    "sit cross-legged on the floor",

    # "make the person raise one hand",
    # "change the pose to raising one hand",
    # "make the person cross both arms",
    # "change the pose to crossing arms",
    # "make the person rest hands on hips",
    # "change the pose to hands on hips"
]


def create_random_prompt():
    subj = random.choice(subjects)
    bg = random.choice(backgrounds)
    style = random.choice(styles)
    instr = random.choice(instructions)

    # Prompt A (Awal): Berdiri
    prompt_a = f"photo of {subj} standing {bg}, {style}"

    # Prompt B (Target): Duduk
    # Penting: Struktur kalimat harus mirip agar background tidak berubah drastis
    prompt_b = f"photo of {subj} sitting {bg}, {style}"

    return prompt_a, prompt_b, instr

# ==========================================
# 4. LOOP GENERATE GAMBAR
# ==========================================
if not os.path.exists(IMAGES_DIR):
    os.makedirs(IMAGES_DIR)

# Hapus file metadata lama jika ada (biar fresh)
if os.path.exists(METADATA_PATH):
    os.remove(METADATA_PATH)

print(f"Mulai generate {NUM_SAMPLES} pasang gambar...")

for i in tqdm(range(NUM_SAMPLES)):
    # 1. Buat Prompt
    prompt_input, prompt_target, instruction = create_random_prompt()

    # 2. Tentukan SEED (Kunci Rahasia)
    # Kita pakai seed yang sama untuk input & target agar identitas & background mirip
    seed = random.randint(0, 2**32 - 1)
    generator = torch.Generator(device).manual_seed(seed)

    # 3. Generate Image A (Berdiri)
    image_a = pipe(
        prompt_input,
        generator=generator,
        guidance_scale=7.5
    ).images[0]

    # 4. Generate Image B (Duduk) - Reset generator ke seed yang sama!
    generator = torch.Generator(device).manual_seed(seed)
    image_b = pipe(
        prompt_target,
        generator=generator,
        guidance_scale=7.5
    ).images[0]

    # 5. Simpan Gambar
    filename_a = f"{i:05d}_original.jpg"
    filename_b = f"{i:05d}_edited.jpg"

    path_a = os.path.join(IMAGES_DIR, filename_a)
    path_b = os.path.join(IMAGES_DIR, filename_b)

    image_a.save(path_a)
    image_b.save(path_b)

    # 6. Simpan Metadata (JSONL Format)
    # Path di metadata harus relatif terhadap folder dataset nanti
    metadata_entry = {
        "original_image": f"images/{filename_a}",
        "edit_prompt": instruction,
        "edited_image": f"images/{filename_b}"
    }

    with open(METADATA_PATH, "a") as f:
        f.write(json.dumps(metadata_entry) + "\n")

print("\nSelesai! Dataset tersimpan di folder 'dataset/'")

from google.colab import files

# 1. Zip the 'dataset' folder
# The -r flag ensures it zips the folder recursively (including subfolders like 'images')
!zip -r dataset_backup.zip dataset/

# 2. Trigger the browser download
files.download('dataset_backup.zip')

pip install peft accelerate transformers diffusers bitsandbytes

import torch
from torch.utils.data import Dataset, DataLoader
from torchvision import transforms
from diffusers import StableDiffusionInstructPix2PixPipeline, DDPMScheduler
from peft import LoraConfig, get_peft_model
from PIL import Image
import json
import os
from tqdm.auto import tqdm
import shutil

# ==============================================================================
# FINE-TUNING SECTION (WITH CHECKPOINTING)
# ==============================================================================

# 1. Konfigurasi Training
TRAIN_OUTPUT_DIR = "./lora_instruct_pose_v2"
DATASET_DIR = "./dataset"
BATCH_SIZE = 4
EPOCHS = 10                     # Kita set agak banyak tidak apa-apa, karena kita akan simpan checkpoint tiap epoch
LEARNING_RATE = 1e-4            # TURUN DARI 1e-4 AGAR LEBIH STABIL (Mencegah Overfitting/Gosong)
GRADIENT_ACCUMULATION_STEPS = 4
SAVE_EVERY_EPOCH = True         # Fitur baru: Simpan model setiap selesai 1 epoch

# 2. Dataset Loader (Tidak Berubah)
class PoseDataset(Dataset):
    def __init__(self, data_dir, tokenizer):
        self.data_dir = data_dir
        self.tokenizer = tokenizer
        self.metadata = []
        if os.path.exists(os.path.join(data_dir, "metadata.jsonl")):
            with open(os.path.join(data_dir, "metadata.jsonl"), 'r') as f:
                for line in f:
                    self.metadata.append(json.loads(line))

        self.transform = transforms.Compose([
            transforms.Resize((512, 512)),
            transforms.ToTensor(),
            transforms.Normalize([0.5], [0.5])
        ])

    def __len__(self):
        return len(self.metadata)

    def __getitem__(self, idx):
        entry = self.metadata[idx]
        img_original = Image.open(os.path.join(self.data_dir, entry['original_image'])).convert("RGB")
        img_edited = Image.open(os.path.join(self.data_dir, entry['edited_image'])).convert("RGB")
        text_inputs = self.tokenizer(
            entry['edit_prompt'], padding="max_length", max_length=77, truncation=True, return_tensors="pt"
        )
        return {
            "pixel_values_original": self.transform(img_original),
            "pixel_values_edited": self.transform(img_edited),
            "input_ids": text_inputs.input_ids[0]
        }

# 3. Fungsi Training Utama
def run_fine_tuning(editor_instance):
    print(f" Memulai Fine-Tuning Pro (Batch: {BATCH_SIZE} | LR: {LEARNING_RATE})...")

    pipeline = editor_instance.pipe
    unet = pipeline.unet
    tokenizer = pipeline.tokenizer

    unet.train()
    weight_dtype = torch.float16

    # Freeze Base Model
    for param in unet.parameters():
        param.requires_grad = False

    # Inject LoRA
    try:
        # Cek apakah adapter sudah ada untuk menghindari error double injection
        if not hasattr(unet, "peft_config"):
            lora_config = LoraConfig(
                r=16,
                lora_alpha=32,
                target_modules=["to_k", "to_q", "to_v", "to_out.0"],
                init_lora_weights="gaussian"
            )
            unet = get_peft_model(unet, lora_config)
            print("LoRA Injected successfully.")
        else:
            print(" Model sudah memiliki adapter LoRA, melanjutkan...")
    except Exception as e:
        print(f" Warning pada injeksi LoRA: {e}")

    optimizer = torch.optim.AdamW(
        filter(lambda p: p.requires_grad, unet.parameters()),
        lr=LEARNING_RATE
    )

    if not os.path.exists(DATASET_DIR):
        print("Folder dataset tidak ditemukan.")
        return

    train_dataset = PoseDataset(DATASET_DIR, tokenizer)
    if len(train_dataset) == 0:
        print("Dataset kosong.")
        return

    dataloader = DataLoader(train_dataset, batch_size=BATCH_SIZE, shuffle=True)
    device = editor_instance.device

    # --- TRAINING LOOP ---
    for epoch in range(EPOCHS):
        progress_bar = tqdm(dataloader, desc=f"Epoch {epoch+1}/{EPOCHS}")
        epoch_loss = 0

        for step, batch in enumerate(progress_bar):
            # Move to Device & Cast to FP16
            orig = batch["pixel_values_original"].to(device, dtype=weight_dtype)
            edit = batch["pixel_values_edited"].to(device, dtype=weight_dtype)
            ids = batch["input_ids"].to(device)

            # VAE Encoding
            latents_orig = pipeline.vae.encode(orig).latent_dist.sample() * 0.18215
            latents_edit = pipeline.vae.encode(edit).latent_dist.sample() * 0.18215

            # Noise Generation
            noise = torch.randn_like(latents_edit)
            bsz = latents_edit.shape[0]
            timesteps = torch.randint(0, pipeline.scheduler.config.num_train_timesteps, (bsz,), device=device)

            noisy_latents = pipeline.scheduler.add_noise(latents_edit, noise, timesteps)

            # Text Encoding
            encoder_hidden_states = pipeline.text_encoder(ids)[0]

            # Concatenate Inputs (InstructPix2Pix spec)
            combined_latents = torch.cat([noisy_latents, latents_orig], dim=1)

            # Cast inputs to correct dtype
            combined_latents = combined_latents.to(dtype=weight_dtype)
            encoder_hidden_states = encoder_hidden_states.to(dtype=weight_dtype)

            # Predict
            noise_pred = unet(combined_latents, timesteps, encoder_hidden_states).sample

            # Calculate Loss
            loss = torch.nn.functional.mse_loss(noise_pred, noise, reduction="mean")

            # Gradient Accumulation
            loss = loss / GRADIENT_ACCUMULATION_STEPS
            loss.backward()

            if (step + 1) % GRADIENT_ACCUMULATION_STEPS == 0:
                optimizer.step()
                optimizer.zero_grad()

            epoch_loss += loss.item()
            progress_bar.set_postfix({"loss": loss.item() * GRADIENT_ACCUMULATION_STEPS})

        # === SAVE CHECKPOINT SETIAP EPOCH ===
        if SAVE_EVERY_EPOCH:
            checkpoint_dir = os.path.join(TRAIN_OUTPUT_DIR, f"checkpoint-epoch-{epoch+1}")
            os.makedirs(checkpoint_dir, exist_ok=True)

            # Simpan adapter LoRA
            unet.save_pretrained(checkpoint_dir)
            print(f"\n Checkpoint saved: {checkpoint_dir}")

    # Save Final Model (sebagai 'latest')
    final_dir = os.path.join(TRAIN_OUTPUT_DIR, "latest")
    os.makedirs(final_dir, exist_ok=True)
    unet.save_pretrained(final_dir)
    print(f" Fine-Tuning Selesai! Model final di: {final_dir}")

editor_base = ProfessionalImageEditor(config)
run_fine_tuning(editor_base)

# ==============================================================================
# PERBANDINGAN: MODEL ASLI vs FINE-TUNED
# ==============================================================================

# 1. Setup Config untuk Model Asli
config_original = ModelConfig(use_instruct_pix2pix=True, lora_path=None) # Tanpa LoRA
print("\n--- Memuat Model Asli ---")
editor_original = ProfessionalImageEditor(config_original)

# 2. Setup Config untuk Model Fine-Tuned
# Pastikan path ini sesuai dengan folder output training di atas
LORA_PATH = "./lora_instruct_pose_v2/checkpoint-epoch-9"

if os.path.exists(LORA_PATH):
    print("\n--- Memuat Model Fine-Tuned ---")
    config_finetuned = ModelConfig(use_instruct_pix2pix=True, lora_path=LORA_PATH)
    editor_finetuned = ProfessionalImageEditor(config_finetuned)
else:
    print("Path LoRA tidak ditemukan. Jalankan training terlebih dahulu.")
    editor_finetuned = None

# 3. Fungsi Komparasi Visual
def compare_models(image_path, prompt, steps=30):
    if not os.path.exists(image_path):
        print("Image not found")
        return

    original_img = Image.open(image_path).convert("RGB")

    # Edit dengan Model Asli
    print("Generating with Original Model...")
    res_orig, _ = editor_original.edit_image(original_img, prompt, num_inference_steps=steps,guidance_scale=7.5, image_guidance_scale=1.5, seed=42, use_controlnet=False)

    # Edit dengan Model Fine-Tuned
    res_ft = None
    if editor_finetuned:
        print("Generating with Fine-Tuned Model...")
        res_ft, _ = editor_finetuned.edit_image(original_img, prompt, num_inference_steps=steps,guidance_scale=7.5, image_guidance_scale=1.5, seed=42, use_controlnet=False)

    # Tampilkan
    fig, axes = plt.subplots(1, 3, figsize=(18, 6))

    axes[0].imshow(original_img)
    axes[0].set_title("Input Image")
    axes[0].axis("off")

    axes[1].imshow(res_orig)
    axes[1].set_title("Original Model")
    axes[1].axis("off")

    if res_ft:
        axes[2].imshow(res_ft)
        axes[2].set_title("Fine-Tuned (LoRA)")
        axes[2].axis("off")
    else:
        axes[2].text(0.5, 0.5, "LoRA Not Loaded", ha='center')

    plt.show()


TEST_IMAGE = "/content/berdiri.jpg"
TEST_PROMPT = "make him sit on a chair"

compare_models(TEST_IMAGE, TEST_PROMPT)

# ==============================================================================
# PERBANDINGAN: MODEL ASLI vs FINE-TUNED
# ==============================================================================

# 1. Setup Config untuk Model Asli
config_original = ModelConfig(use_instruct_pix2pix=True, lora_path=None) # Tanpa LoRA
print("\n--- Memuat Model Asli ---")
editor_original = ProfessionalImageEditor(config_original)

# 2. Setup Config untuk Model Fine-Tuned
# Pastikan path ini sesuai dengan folder output training di atas
LORA_PATH = "./lora_instruct_pose_v2/checkpoint-epoch-8"

if os.path.exists(LORA_PATH):
    print("\n--- Memuat Model Fine-Tuned ---")
    config_finetuned = ModelConfig(use_instruct_pix2pix=True, lora_path=LORA_PATH)
    editor_finetuned = ProfessionalImageEditor(config_finetuned)
else:
    print(" Path LoRA tidak ditemukan. Jalankan training terlebih dahulu.")
    editor_finetuned = None

# 3. Fungsi Komparasi Visual
def compare_models(image_path, prompt, steps=30):
    if not os.path.exists(image_path):
        print(" Image not found")
        return

    original_img = Image.open(image_path).convert("RGB")

    # Edit dengan Model Asli
    print(" Generating with Original Model...")
    res_orig, _ = editor_original.edit_image(original_img, prompt, num_inference_steps=steps,guidance_scale=7.5, image_guidance_scale=1.5, seed=42, use_controlnet=False)

    # Edit dengan Model Fine-Tuned
    res_ft = None
    if editor_finetuned:
        print(" Generating with Fine-Tuned Model...")
        res_ft, _ = editor_finetuned.edit_image(original_img, prompt, num_inference_steps=steps,guidance_scale=7.5, image_guidance_scale=1.5, seed=42, use_controlnet=False)

    # Tampilkan
    fig, axes = plt.subplots(1, 3, figsize=(18, 6))

    axes[0].imshow(original_img)
    axes[0].set_title("Input Image")
    axes[0].axis("off")

    axes[1].imshow(res_orig)
    axes[1].set_title("Original Model")
    axes[1].axis("off")

    if res_ft:
        axes[2].imshow(res_ft)
        axes[2].set_title("Fine-Tuned (LoRA)")
        axes[2].axis("off")
    else:
        axes[2].text(0.5, 0.5, "LoRA Not Loaded", ha='center')

    plt.show()

TEST_IMAGE = "/content/berdiri.jpg"
TEST_PROMPT = "make the person sit down"

compare_models(TEST_IMAGE, TEST_PROMPT)

# ==============================================================================
# PERBANDINGAN: MODEL ASLI vs FINE-TUNED
# ==============================================================================

# 1. Setup Config untuk Model Asli
config_original = ModelConfig(use_instruct_pix2pix=True, lora_path=None) # Tanpa LoRA
print("\n--- Memuat Model Asli ---")
editor_original = ProfessionalImageEditor(config_original)

# 2. Setup Config untuk Model Fine-Tuned
# Pastikan path ini sesuai dengan folder output training di atas
LORA_PATH = "./lora_instruct_pose_v2/checkpoint-epoch-10"

if os.path.exists(LORA_PATH):
    print("\n--- Memuat Model Fine-Tuned ---")
    config_finetuned = ModelConfig(use_instruct_pix2pix=True, lora_path=LORA_PATH)
    editor_finetuned = ProfessionalImageEditor(config_finetuned)
else:
    print(" Path LoRA tidak ditemukan. Jalankan training terlebih dahulu.")
    editor_finetuned = None

# 3. Fungsi Komparasi Visual
def compare_models(image_path, prompt, steps=30):
    if not os.path.exists(image_path):
        print("Image not found")
        return

    original_img = Image.open(image_path).convert("RGB")

    # Edit dengan Model Asli
    print(" Generating with Original Model...")
    res_orig, _ = editor_original.edit_image(original_img, prompt, num_inference_steps=steps,guidance_scale=7.5, image_guidance_scale=1.5, seed=42, use_controlnet=False)

    # Edit dengan Model Fine-Tuned
    res_ft = None
    if editor_finetuned:
        print(" Generating with Fine-Tuned Model...")
        res_ft, _ = editor_finetuned.edit_image(original_img, prompt, num_inference_steps=steps,guidance_scale=7.5, image_guidance_scale=1.5, seed=42, use_controlnet=False)

    # Tampilkan
    fig, axes = plt.subplots(1, 3, figsize=(18, 6))

    axes[0].imshow(original_img)
    axes[0].set_title("Input Image")
    axes[0].axis("off")

    axes[1].imshow(res_orig)
    axes[1].set_title("Original Model")
    axes[1].axis("off")

    if res_ft:
        axes[2].imshow(res_ft)
        axes[2].set_title("Fine-Tuned (LoRA)")
        axes[2].axis("off")
    else:
        axes[2].text(0.5, 0.5, "LoRA Not Loaded", ha='center')

    plt.show()


TEST_IMAGE = "/content/berdiri.jpg"
TEST_PROMPT = "a man sit on a bench"

compare_models(TEST_IMAGE, TEST_PROMPT)

# ==============================================================================
#  PERBANDINGAN: MODEL ASLI vs FINE-TUNED
# ==============================================================================

# 1. Setup Config untuk Model Asli
config_original = ModelConfig(use_instruct_pix2pix=True, lora_path=None) # Tanpa LoRA
print("\n--- Memuat Model Asli ---")
editor_original = ProfessionalImageEditor(config_original)

# 2. Setup Config untuk Model Fine-Tuned
# Pastikan path ini sesuai dengan folder output training di atas
LORA_PATH = "./lora_instruct_pose_v2/checkpoint-epoch-10"

if os.path.exists(LORA_PATH):
    print("\n--- Memuat Model Fine-Tuned ---")
    config_finetuned = ModelConfig(use_instruct_pix2pix=True, lora_path=LORA_PATH)
    editor_finetuned = ProfessionalImageEditor(config_finetuned)
else:
    print("Path LoRA tidak ditemukan. Jalankan training terlebih dahulu.")
    editor_finetuned = None

# 3. Fungsi Komparasi Visual
def compare_models(image_path, prompt, steps=30):
    if not os.path.exists(image_path):
        print("Image not found")
        return

    original_img = Image.open(image_path).convert("RGB")

    # Edit dengan Model Asli
    print("Generating with Original Model...")
    res_orig, _ = editor_original.edit_image(original_img, prompt, num_inference_steps=steps,guidance_scale=9.5, image_guidance_scale=1.5, seed=42, use_controlnet=False)

    # Edit dengan Model Fine-Tuned
    res_ft = None
    if editor_finetuned:
        print("Generating with Fine-Tuned Model...")
        res_ft, _ = editor_finetuned.edit_image(original_img, prompt, num_inference_steps=steps,guidance_scale=7.5, image_guidance_scale=1.5, seed=42, use_controlnet=False)

    # Tampilkan
    fig, axes = plt.subplots(1, 3, figsize=(18, 6))

    axes[0].imshow(original_img)
    axes[0].set_title("Input Image")
    axes[0].axis("off")

    axes[1].imshow(res_orig)
    axes[1].set_title("Original Model")
    axes[1].axis("off")

    if res_ft:
        axes[2].imshow(res_ft)
        axes[2].set_title("Fine-Tuned (LoRA)")
        axes[2].axis("off")
    else:
        axes[2].text(0.5, 0.5, "LoRA Not Loaded", ha='center')

    plt.show()

TEST_IMAGE = "/content/berdiri.jpg"
TEST_PROMPT = "sit cross-legged on the floor"

compare_models(TEST_IMAGE, TEST_PROMPT)

# ==============================================================================
#  PERBANDINGAN: MODEL ASLI vs FINE-TUNED
# ==============================================================================

# 1. Setup Config untuk Model Asli
config_original = ModelConfig(use_instruct_pix2pix=True, lora_path=None) # Tanpa LoRA
print("\n--- Memuat Model Asli ---")
editor_original = ProfessionalImageEditor(config_original)

# 2. Setup Config untuk Model Fine-Tuned
# Pastikan path ini sesuai dengan folder output training di atas
LORA_PATH = "./lora_instruct_pose_v2/checkpoint-epoch-10"

if os.path.exists(LORA_PATH):
    print("\n--- Memuat Model Fine-Tuned ---")
    config_finetuned = ModelConfig(use_instruct_pix2pix=True, lora_path=LORA_PATH)
    editor_finetuned = ProfessionalImageEditor(config_finetuned)
else:
    print("Path LoRA tidak ditemukan. Jalankan training terlebih dahulu.")
    editor_finetuned = None

# 3. Fungsi Komparasi Visual
def compare_models(image_path, prompt, steps=30):
    if not os.path.exists(image_path):
        print("Image not found")
        return

    original_img = Image.open(image_path).convert("RGB")

    # Edit dengan Model Asli
    print("Generating with Original Model...")
    res_orig, _ = editor_original.edit_image(original_img, prompt, num_inference_steps=steps,guidance_scale=7.5, image_guidance_scale=1.5, seed=42, use_controlnet=False)

    # Edit dengan Model Fine-Tuned
    res_ft = None
    if editor_finetuned:
        print("Generating with Fine-Tuned Model...")
        res_ft, _ = editor_finetuned.edit_image(original_img, prompt, num_inference_steps=steps,guidance_scale=7.5, image_guidance_scale=1.5, seed=42, use_controlnet=False)

    # Tampilkan
    fig, axes = plt.subplots(1, 3, figsize=(18, 6))

    axes[0].imshow(original_img)
    axes[0].set_title("Input Image")
    axes[0].axis("off")

    axes[1].imshow(res_orig)
    axes[1].set_title("Original Model")
    axes[1].axis("off")

    if res_ft:
        axes[2].imshow(res_ft)
        axes[2].set_title("Fine-Tuned (LoRA)")
        axes[2].axis("off")
    else:
        axes[2].text(0.5, 0.5, "LoRA Not Loaded", ha='center')

    plt.show()

# CONTOH PENGGUNAAN
# Ganti dengan path gambar tes Anda
TEST_IMAGE = "dataset/images/00027_original.jpg"
TEST_PROMPT = "make her sit on a chair"

compare_models(TEST_IMAGE, TEST_PROMPT)

!pip install torchmetrics lpips transformers

!pip install torchmetrics[image] transformers scipy pandas matplotlib seaborn

import torch
import torch.nn.functional as F
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from PIL import Image
from tqdm.auto import tqdm
from transformers import CLIPProcessor, CLIPModel
from torchmetrics.image import PeakSignalNoiseRatio, StructuralSimilarityIndexMeasure
from torchmetrics.image.lpip import LearnedPerceptualImagePatchSimilarity

class AdvancedEvaluator:
    def __init__(self, device="cuda"):
        self.device = device
        print("Loading Evaluation Models...")

        # 1. Structural Metrics
        self.psnr = PeakSignalNoiseRatio(data_range=1.0).to(device)
        self.ssim = StructuralSimilarityIndexMeasure(data_range=1.0).to(device)

        # 2. Perceptual Metric (LPIPS)
        # Net type 'alex' is standard for research papers
        self.lpips = LearnedPerceptualImagePatchSimilarity(net_type='alex').to(device)

        # 3. Semantic Metric (CLIP)
        self.clip_model = CLIPModel.from_pretrained("openai/clip-vit-base-patch32").to(device)
        self.clip_processor = CLIPProcessor.from_pretrained("openai/clip-vit-base-patch32")

        print("Evaluator Ready!")

    def preprocess_image(self, image):
        """Convert PIL to Tensor (0-1 range)"""
        if isinstance(image, Image.Image):
            image = np.array(image).astype(np.float32) / 255.0
            image = torch.from_numpy(image).permute(2, 0, 1).unsqueeze(0)
        return image.to(self.device)

    def get_clip_features(self, image, text):
        inputs = self.clip_processor(text=[text], images=image, return_tensors="pt", padding=True)
        inputs = {k: v.to(self.device) for k, v in inputs.items()}
        with torch.no_grad():
            outputs = self.clip_model(**inputs)
        return outputs.image_embeds, outputs.text_embeds

    def calculate_directional_clip(self, img_orig, img_edit, text_orig, text_edit):
        """
        Mengukur apakah arah perubahan gambar (Delta I) sejajar dengan arah perubahan teks (Delta T).
        Ini metrik paling penting untuk Image Editing.
        """
        # Get embeddings
        inputs_orig = self.clip_processor(text=[text_orig], images=img_orig, return_tensors="pt", padding=True).to(self.device)
        inputs_edit = self.clip_processor(text=[text_edit], images=img_edit, return_tensors="pt", padding=True).to(self.device)

        with torch.no_grad():
            feat_img_orig = self.clip_model.get_image_features(**inputs_orig)
            feat_img_edit = self.clip_model.get_image_features(**inputs_edit)
            feat_text_orig = self.clip_model.get_text_features(**inputs_orig)
            feat_text_edit = self.clip_model.get_text_features(**inputs_edit)

        # Normalize
        feat_img_orig /= feat_img_orig.norm(dim=-1, keepdim=True)
        feat_img_edit /= feat_img_edit.norm(dim=-1, keepdim=True)
        feat_text_orig /= feat_text_orig.norm(dim=-1, keepdim=True)
        feat_text_edit /= feat_text_edit.norm(dim=-1, keepdim=True)

        # Calculate Direction Vectors
        delta_img = feat_img_edit - feat_img_orig
        delta_text = feat_text_edit - feat_text_orig

        # Cosine Similarity of the directions
        similarity = F.cosine_similarity(delta_img, delta_text)
        return similarity.item()

    def evaluate_sample(self, original_image, generated_image, original_prompt, target_prompt):
        """Menghitung SEMUA metrik untuk satu pasang gambar"""
        img_orig_tensor = self.preprocess_image(original_image)
        img_gen_tensor = self.preprocess_image(generated_image)

        # A. Structural (Higher is Better usually, but for edit we want balance)
        psnr_score = self.psnr(img_gen_tensor, img_orig_tensor).item()
        ssim_score = self.ssim(img_gen_tensor, img_orig_tensor).item()

        # B. Perceptual (Lower is Better - measures distortion)
        # Normalize to [-1, 1] for LPIPS
        lpips_score = self.lpips(img_gen_tensor * 2 - 1, img_orig_tensor * 2 - 1).item()

        # C. Alignment (CLIP Score) - Higher is Better
        # Seberapa cocok gambar hasil dengan target prompt
        inputs = self.clip_processor(text=[target_prompt], images=generated_image, return_tensors="pt", padding=True).to(self.device)
        with torch.no_grad():
            clip_out = self.clip_model(**inputs)
        clip_score = clip_out.logits_per_image.item() / 100.0 # Standardize to 0-1 approx

        # D. Directional CLIP (Higher is Better)
        dir_clip = self.calculate_directional_clip(original_image, generated_image, original_prompt, target_prompt)

        return {
            "PSNR": psnr_score,
            "SSIM": ssim_score,
            "LPIPS": lpips_score,
            "CLIP_Score": clip_score,
            "Directional_CLIP": dir_clip
        }

    def visualize_radar(self, metrics_avg):
        """Membuat Radar Chart untuk presentasi"""
        categories = list(metrics_avg.keys())
        values = list(metrics_avg.values())

        # Normalisasi data agar grafik bagus (hanya visualisasi)
        # SSIM (0-1), LPIPS (0-1, inverted), Directional (0-1)
        # Kita sesuaikan skala agar 1.0 = Terbaik
        viz_values = []
        for k, v in metrics_avg.items():
            if k == "LPIPS":
                viz_values.append(1.0 - v) # Invert LPIPS because lower is better
            elif k == "PSNR":
                viz_values.append(min(v / 30.0, 1.0)) # Normalize PSNR (assume max 30)
            elif k == "CLIP_Score":
                viz_values.append(min(v / 0.35, 1.0)) # Normalize CLIP (assume max 35 logits)
            else:
                viz_values.append(v)

        # Setup Plot
        N = len(categories)
        angles = [n / float(N) * 2 * np.pi for n in range(N)]
        angles += angles[:1]
        viz_values += viz_values[:1]

        fig, ax = plt.subplots(figsize=(6, 6), subplot_kw=dict(polar=True))
        ax.plot(angles, viz_values, linewidth=2, linestyle='solid', color='blue')
        ax.fill(angles, viz_values, 'b', alpha=0.1)

        ax.set_xticks(angles[:-1])
        ax.set_xticklabels(categories)
        plt.title("Model Performance Overview", y=1.1)
        plt.show()

# 1. Inisialisasi
evaluator = AdvancedEvaluator()

# 2. Siapkan Data Test (Contoh List)
# Format: {'orig': PIL_Image, 'gen': PIL_Image, 'prompt_orig': str, 'prompt_target': str}
test_samples = []

# 1. Pastikan Editor sudah siap
# (Code ini mengasumsikan Anda sudah menjalankan cell class ProfessionalImageEditor sebelumnya)
if 'editor' not in locals():
    print("Inisialisasi Editor baru...")
    config_finetuned = ModelConfig(use_instruct_pix2pix=True, lora_path=LORA_PATH)
    editor_finetuned = ProfessionalImageEditor(config_finetuned)

test_samples = []

METADATA_PATH = "./dataset/metadata.jsonl" # Pastikan path ini sesuai dengan Cell 12
DATASET_DIR = "./dataset"

if os.path.exists(METADATA_PATH):
    print(f" Memuat dataset dari: {METADATA_PATH}")

    with open(METADATA_PATH, 'r') as f:
        # Baca semua baris metadata
        lines = f.readlines()

    # Ambil 5 sampel pertama untuk testing
    # Ganti [:5] dengan jumlah yang Anda mau, misal [:10]
    samples_to_test = lines[:5]

    print(f"Mulai generating {len(samples_to_test)} sampel test...")

    for line in tqdm(samples_to_test, desc="Processing"):
        entry = json.loads(line)

        # Load Original Image
        img_path = os.path.join(DATASET_DIR, entry['original_image'])
        if not os.path.exists(img_path):
            print(f"Gambar tidak ditemukan: {img_path}")
            continue

        original_image = Image.open(img_path).convert("RGB")
        target_prompt = entry['edit_prompt']

        # Jalankan Editor
        # Pastikan 'editor' (baik base atau fine-tuned) sudah di-init sebelumnya
        result_image, _ = editor_finetuned.edit_image(
            image=original_image,
            prompt=target_prompt,
            num_inference_steps=30,
            guidance_scale=7.5,
            image_guidance_scale=1.5,
            seed=42,
            use_controlnet=False # Added this line to explicitly disable ControlNet for evaluation
        )

        test_samples.append({
            'orig': original_image,
            'gen': result_image,
            'prompt_orig': "original image", # Default karena metadata tidak simpan caption asli
            'prompt_target': target_prompt
        })
else:
    print("Metadata dataset tidak ditemukan! Pastikan Anda sudah menjalankan Cell Generate Dataset.")


# 3. Jalankan Evaluasi
results = []
print(f"\n Evaluating {len(test_samples)} samples...")

for sample in tqdm(test_samples):
    metrics = evaluator.evaluate_sample(
        sample['orig'],
        sample['gen'],
        sample['prompt_orig'],
        sample['prompt_target']
    )
    results.append(metrics)

# 4. Tampilkan Hasil Rata-rata
df_results = pd.DataFrame(results)
print("\n=== Detailed Metrics Report ===")
print(df_results.mean())

# 5. Buat Radar Chart untuk PPT
evaluator.visualize_radar(df_results.mean().to_dict())